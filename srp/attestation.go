package srp

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"go.fergus.london/nopasswords/core"
)

// AttestationRequest contains the data sent from client to server during registration.
type AttestationRequest struct {
	// UserID identifies the user being registered
	UserIdentifier string `json:"identifier"`

	// Salt is the random salt generated by the client
	Salt []byte `json:"salt"`

	// Verifier is the SRP verifier computed by the client
	Verifier []byte `json:"verifier"`

	// Group identifies which RFC5054 group to use
	Group int `json:"group"`
}

// AttestationResponse contains the server's response after successful registration.
type AttestationResponse struct {
	// Success indicates whether registration succeeded
	Success bool `json:"success"`

	// UserID is the registered user's identifier
	UserIdentifier string `json:"identifier"`

	// Error contains any error message if Success is false
	Error string `json:"error,omitempty"`
}

// AttestationSuccessFunc is a callback function for use after a successful
// attestation event: i.e. the user has successfully provided proof of a new
// password.
//
// TODO: Explain why this is useful.
type AttestationSucccessFunc func(Parameters)

// AttestationHandlerFunc handles the attestation of new credentials.
//
// Request: The Client sends a second request containing four values:
//
//	an identifier associated with the user, a Salt, a Verifier,
//	and their Group.
//
// Processing:
//
//	-> Request Validation: HTTP Method and Payload Validity (i.e. JSON)
//	  -> is POST request?
//	  -> is valid JSON?
//	  -> is the user identifier present?
//	  -> is salt a correct size?
//	  -> is the verifier present?
//	  -> is the group correct?
//	-> Store Parameters associated with the user identifier
//	  -> Salt, Verifier, Group
//	-> Get AssertionState
//	  -> UserIdentifier -> [Group, b, B, v]
//	-> Perform Computations
//	-> Call SuccessHandlerFunc
//	  -> User Identifier, Request, Response
//	-> Clear Cache Entry
//	-> Return Response
//
// Response:  The Server responds with two values: a boolean indicating
//
//	whether the operation was successful and `M2` which is their
//	proof. In the event of a failure, `M2` is replaced with an
//	error string.
//
// Security Considerations:
// @mitigation Information Disclosure: The verifier cannot be used to recover
// the password, even if the database is compromised.
// @risk Repudiation: Registration events are logged for audit purposes.
func (m *Manager) AttestationHandlerFunc(h AttestationSucccessFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		eventID := generateEventID()
		startTime := time.Now()
		ctx := r.Context()

		if r.Method != http.MethodPost {
			sendAttestationResponse(w, &AttestationResponse{
				Success:        false,
				UserIdentifier: "Method not allowed",
			})
			return
		}

		var req AttestationRequest // TODO: AttestationRequest. More generic.
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			fmt.Println(err)
			sendAttestationResponse(w, &AttestationResponse{
				Success:        false,
				UserIdentifier: "Invalid request",
			})
			return
		}

		// Validate request
		if req.UserIdentifier == "" {
			m.logAuditEvent(ctx, eventID, core.EventCredentialRegister, req.UserIdentifier, "", core.OutcomeFailure, "empty_user_id", nil)
			sendAttestationResponse(w, &AttestationResponse{
				Success:        false,
				UserIdentifier: "user ID cannot be empty",
			})
			return
		}

		if len(req.Salt) < MinSaltLength {
			m.logAuditEvent(ctx, eventID, core.EventCredentialRegister, req.UserIdentifier, "", core.OutcomeFailure, "invalid_salt_length", nil)
			sendAttestationResponse(w, &AttestationResponse{
				Success:        false,
				UserIdentifier: "insufficient salt length",
			})
			return
		}

		if len(req.Verifier) == 0 {
			m.logAuditEvent(ctx, eventID, core.EventCredentialRegister, req.UserIdentifier, "", core.OutcomeFailure, "empty_verifier", nil)
			sendAttestationResponse(w, &AttestationResponse{
				Success:        false,
				UserIdentifier: "verifier cannot be empty",
			})
			return
		}

		// Validate group
		if req.Group != m.config.Group {
			m.logAuditEvent(ctx, eventID, core.EventCredentialRegister, req.UserIdentifier, "", core.OutcomeFailure, "group_mismatch", map[string]interface{}{
				"requested_group": req.Group,
				"expected_group":  m.config.Group,
			})

			sendAttestationResponse(w, &AttestationResponse{
				Success:        false,
				UserIdentifier: "group mismatch",
			})
			return
		}

		// Create verifier record
		assertionParams := &Parameters{ // TODO: Thse structs are now identical. Embed Verifier within req?
			UserIdentifier: req.UserIdentifier,
			Salt:           req.Salt,
			Verifier:       req.Verifier,
			Group:          req.Group,
		}

		if err := m.config.Store.StoreForUserIdentifier(req.UserIdentifier, assertionParams); err != nil {
			// TODO: Audit Log
			sendAttestationResponse(w, &AttestationResponse{
				Success:        false,
				UserIdentifier: "unknown error",
			})
			return
		}

		h(*assertionParams)

		// Log successful registration (this should be deferred from the start, and the duration of all requests logged.)
		m.logAuditEvent(ctx, eventID, core.EventCredentialRegister, req.UserIdentifier, credentialID, core.OutcomeSuccess, "", map[string]interface{}{
			"group":    req.Group,
			"duration": time.Since(startTime).Milliseconds(),
		})

		sendAttestationResponse(w, &AttestationResponse{
			Success:        true,
			UserIdentifier: req.UserIdentifier,
		})
	}
}

func sendAttestationResponse(w http.ResponseWriter, resp *AttestationResponse) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(&AttestationResponse{})
}
