// Package srp implements the Secure Remote Password (SRP) protocol for zero-knowledge
// password authentication. SRP allows password-based authentication without transmitting
// passwords or storing password-equivalent data on the server.
//
// This implementation follows RFC5054 with support for 2048-bit, 3072-bit, and 4096-bit
// group parameters.
package srp

import (
	"encoding/json"
	"math/big"
	"time"
)

// Verifier represents the SRP verifier stored on the server.
// The verifier is derived from the user's password and salt, but cannot be used
// to recover the password (one-way function).
//
// Security Considerations:
// @mitigation Information Disclosure: Verifiers do not allow password recovery.
// Even if the database is compromised, attackers cannot derive the password from the verifier.
type Verifier struct {
	// UserID identifies the user this verifier belongs to
	UserID string `json:"user_id"`

	// Salt is the random salt used during registration (minimum 128 bits)
	Salt []byte `json:"salt"`

	// Verifier is the SRP verifier value (v = g^x mod N, where x = H(salt | password))
	Verifier []byte `json:"verifier"`

	// Group identifies which RFC5054 group was used (3, 4, or 5)
	Group int `json:"group"`

	// CreatedAt records when this verifier was created
	CreatedAt time.Time `json:"created_at"`

	// UpdatedAt records the last time this verifier was updated
	UpdatedAt time.Time `json:"updated_at"`
}

// MarshalBinary serializes the Verifier to JSON for storage.
func (v *Verifier) MarshalBinary() ([]byte, error) {
	return json.Marshal(v)
}

// UnmarshalBinary deserializes the Verifier from JSON.
func (v *Verifier) UnmarshalBinary(data []byte) error {
	return json.Unmarshal(data, v)
}

// RegistrationRequest contains the data sent from client to server during registration.
type RegistrationRequest struct {
	// UserID identifies the user being registered
	UserID string `json:"identifier"`

	// Salt is the random salt generated by the client
	Salt []byte `json:"salt"`

	// Verifier is the SRP verifier computed by the client
	Verifier []byte `json:"verifier"`

	// Group identifies which RFC5054 group to use
	Group int `json:"group"`
}

// RegistrationResponse contains the server's response after successful registration.
type RegistrationResponse struct {
	// Success indicates whether registration succeeded
	Success bool `json:"success"`

	// UserID is the registered user's identifier
	UserID string `json:"identifier"`

	// Error contains any error message if Success is false
	Error string `json:"error,omitempty"`
}

// AuthenticationBeginRequest initiates an SRP authentication flow.
type AuthenticationBeginRequest struct {
	// UserID identifies the user attempting to authenticate
	UserID string `json:"identifier"`

	// Group identifies which RFC5054 group to use (optional, server can choose)
	Group int `json:"group,omitempty"`
}

// AuthenticationBeginResponse contains the server's initial authentication response.
type AuthenticationBeginResponse struct {
	// Salt is the user's salt from registration
	Salt []byte `json:"salt"`

	// B is the server's public ephemeral value
	B []byte `json:"b"`

	// Group identifies which RFC5054 group is being used
	Group int `json:"group"`
}

// AuthenticationFinishRequest contains the client's proof of password knowledge.
type AuthenticationFinishRequest struct {
	// UserID identifies the user attempting to authenticate
	UserID string `json:"identifier"`

	// A is the client's public ephemeral value
	A []byte `json:"a"`

	// M1 is the client's proof (hash of session key and other values)
	M1 []byte `json:"m1"`
}

// AuthenticationFinishResponse contains the server's proof and final authentication result.
type AuthenticationFinishResponse struct {
	// Success indicates whether authentication succeeded
	Success bool `json:"success"`

	// M2 is the server's proof (hash of session key and other values)
	// Only present if Success is true
	M2 []byte `json:"m2,omitempty"`

	// Error contains any error message if Success is false
	Error string `json:"error,omitempty"`
}

// ServerSession represents the server-side state during an SRP authentication flow.
// This must be stored between the Begin and Finish steps.
//
// Security Considerations:
// @risk Elevation of Privilege: Session data must be protected against tampering.
// Store sessions securely (e.g., encrypted, signed, in server memory with timeout).
//
// @risk Denial of Service: Sessions must have expiration to prevent resource exhaustion.
type ServerSession struct {
	// UserID identifies the user this session belongs to
	UserID string `json:"identifier"`

	// Group identifies which RFC5054 group is being used
	Group int `json:"group"`

	// b is the server's private ephemeral value (kept secret)
	// @risk Information Disclosure: Never serialize or expose private ephemeral value
	b *big.Int

	// B is the server's public ephemeral value (sent to client)
	B *big.Int `json:"B"`

	// v is the verifier value from storage
	// @risk Information Disclosure: Never serialize or expose verifier directly
	v *big.Int

	// CreatedAt records when this session was created
	CreatedAt time.Time `json:"created_at"`

	// ExpiresAt records when this session expires
	ExpiresAt time.Time `json:"expires_at"`
}

// MarshalJSON implements custom JSON marshaling for ServerSession.
// big.Int fields are encoded as base64 strings.
func (s *ServerSession) MarshalJSON() ([]byte, error) {
	type Alias ServerSession
	return json.Marshal(&struct {
		B string `json:"B"`
		V string `json:"v"`
		*Alias
	}{
		B:     s.B.Text(16),
		V:     s.v.Text(16),
		Alias: (*Alias)(s),
	})
}

// UnmarshalJSON implements custom JSON unmarshaling for ServerSession.
func (s *ServerSession) UnmarshalJSON(data []byte) error {
	type Alias ServerSession
	aux := &struct {
		B string `json:"B"`
		V string `json:"v"`
		*Alias
	}{
		Alias: (*Alias)(s),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	s.B = new(big.Int)
	s.B.SetString(aux.B, 16)

	s.v = new(big.Int)
	s.v.SetString(aux.V, 16)

	return nil
}

// SessionKey represents the shared session key derived after successful SRP authentication.
// Both client and server independently compute this key, which can be used for subsequent
// cryptographic operations.
//
// Security Considerations:
// @risk Elevation of Privilege: Session keys must be kept secret and used appropriately.
// The application is responsible for session management using this key.
type SessionKey struct {
	// Key is the raw session key bytes
	Key []byte

	// UserID identifies the user this key belongs to
	UserID string

	// Timestamp records when this key was derived
	Timestamp time.Time
}
