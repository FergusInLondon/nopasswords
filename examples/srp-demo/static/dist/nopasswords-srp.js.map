{
  "version": 3,
  "sources": ["index.js", "groups.js", "client.js"],
  "sourcesContent": ["/**\n * NoPasswords SRP Client Library\n *\n * Secure Remote Password (SRP) protocol implementation for zero-knowledge password authentication.\n * Compatible with the NoPasswords Go server implementation.\n *\n * @packageDocumentation\n */\nexport { SRPClient } from './client';\nexport { getGroup, computeK, bigIntToBytes, bytesToBigInt, padBytes } from './groups';\n", "/**\n * RFC5054 SRP group parameters.\n * These must match the server-side implementation exactly.\n */\n/**\n * Get the SRP group parameters for the specified group ID.\n *\n * @param groupID - Group ID (3, 4, or 5)\n * @returns SRP group parameters\n * @throws Error if group ID is invalid\n *\n * @risk Spoofing: Weak group parameters allow offline attacks.\n * Always use RFC5054 standard groups.\n */\nexport function getGroup(groupID) {\n    switch (groupID) {\n        case 3:\n            return getGroup3();\n        case 4:\n            return getGroup4();\n        case 5:\n            return getGroup5();\n        default:\n            throw new Error(`Invalid group ID: ${groupID} (valid: 3, 4, 5)`);\n    }\n}\n/**\n * RFC5054 2048-bit group (recommended minimum).\n */\nfunction getGroup3() {\n    const N = BigInt('0x' +\n        'AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050' +\n        'A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50' +\n        'E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B8' +\n        '55F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773B' +\n        'CA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748' +\n        '544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6' +\n        'AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB6' +\n        '94B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73');\n    const g = BigInt(2);\n    return { N, g, bitLength: 2048 };\n}\n/**\n * RFC5054 3072-bit group (stronger security, higher CPU cost).\n */\nfunction getGroup4() {\n    const N = BigInt('0x' +\n        'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' +\n        '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' +\n        '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' +\n        'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF05' +\n        '98DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB' +\n        '9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B' +\n        'E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718' +\n        '3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33' +\n        'A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7' +\n        'ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864' +\n        'D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E2' +\n        '08E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF');\n    const g = BigInt(5);\n    return { N, g, bitLength: 3072 };\n}\n/**\n * RFC5054 4096-bit group (strongest security, significant CPU cost).\n */\nfunction getGroup5() {\n    const N = BigInt('0x' +\n        'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' +\n        '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' +\n        '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' +\n        'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF05' +\n        '98DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB' +\n        '9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B' +\n        'E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718' +\n        '3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33' +\n        'A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7' +\n        'ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864' +\n        'D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E2' +\n        '08E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7' +\n        '88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8' +\n        'DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2' +\n        '233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9' +\n        '93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199FFFFFFFFFFFFFFFF');\n    const g = BigInt(5);\n    return { N, g, bitLength: 4096 };\n}\n/**\n * Compute the SRP multiplier parameter k = H(N | g).\n *\n * @param group - SRP group parameters\n * @returns Multiplier k\n *\n * @mitigation Tampering: Correct k computation per RFC5054/SRP-6a.\n */\nexport async function computeK(group) {\n    // k = H(N | PAD(g))\n    const NBytes = bigIntToBytes(group.N);\n    const gBytes = bigIntToBytes(group.g);\n    // Pad g to the same length as N\n    const paddedG = new Uint8Array(NBytes.length);\n    paddedG.set(gBytes, paddedG.length - gBytes.length);\n    // Concatenate N and paddedG\n    const combined = new Uint8Array(NBytes.length + paddedG.length);\n    combined.set(NBytes, 0);\n    combined.set(paddedG, NBytes.length);\n    // Hash with SHA-256\n    const hashBuffer = await crypto.subtle.digest('SHA-256', combined);\n    const hashBytes = new Uint8Array(hashBuffer);\n    return bytesToBigInt(hashBytes);\n}\n/**\n * Convert a bigint to a Uint8Array (big-endian).\n */\nexport function bigIntToBytes(value) {\n    const hex = value.toString(16);\n    const paddedHex = hex.length % 2 === 0 ? hex : '0' + hex;\n    const bytes = new Uint8Array(paddedHex.length / 2);\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = parseInt(paddedHex.substr(i * 2, 2), 16);\n    }\n    return bytes;\n}\n/**\n * Convert a Uint8Array to a bigint (big-endian).\n */\nexport function bytesToBigInt(bytes) {\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        const byte = bytes[i].toString(16).padStart(2, '0');\n        hex += byte;\n    }\n    return BigInt('0x' + hex);\n}\n/**\n * Pad bytes to a specific length with leading zeros.\n */\nexport function padBytes(bytes, length) {\n    if (bytes.length >= length) {\n        return bytes;\n    }\n    const padded = new Uint8Array(length);\n    padded.set(bytes, length - bytes.length);\n    return padded;\n}\n", "/**\n * SRP (Secure Remote Password) Client Library\n *\n * This implementation uses WebCrypto API for cryptographic operations and matches\n * the server-side Go implementation for compatibility.\n *\n * @mitigation Information Disclosure: Passwords are never transmitted to the server.\n * @mitigation Tampering: Cryptographic proofs ensure both parties have the correct password.\n */\nimport { getGroup, computeK, bigIntToBytes, bytesToBigInt, padBytes } from './groups';\n/**\n * SRP Client for registration and authentication.\n *\n * Example usage:\n * ```typescript\n * const client = new SRPClient({\n *   group: 3,\n *   baseURL: 'https://api.example.com'\n * });\n *\n * // Registration\n * const regResult = await client.register('user@example.com', 'password123');\n *\n * // Authentication\n * const authResult = await client.authenticate('user@example.com', 'password123');\n * ```\n */\nexport class SRPClient {\n    constructor(config) {\n        this.config = config;\n    }\n    /**\n     * Register a new user with SRP.\n     *\n     * This computes the verifier client-side and sends it to the server along with the salt.\n     * The server stores the verifier but never sees the password.\n     *\n     * @param userID - User identifier (e.g., email)\n     * @param password - User's password\n     * @returns Registration result\n     *\n     * @mitigation Information Disclosure: Password never leaves the client.\n     * @mitigation Spoofing: Verifier cannot be used to recover the password.\n     */\n    async register(userID, password) {\n        try {\n            // Get group parameters\n            const group = getGroup(this.config.group);\n            // Generate random salt (32 bytes = 256 bits)\n            const salt = new Uint8Array(32);\n            crypto.getRandomValues(salt);\n            // Compute x = H(salt | H(userID | \":\" | password))\n            const x = await this.computeX(userID, password, salt);\n            // Compute verifier v = g^x mod N\n            const v = this.modPow(group.g, x, group.N);\n            // Prepare registration request\n            const request = {\n                user_id: userID,\n                salt: this.bytesToBase64(salt),\n                verifier: this.bytesToBase64(bigIntToBytes(v)),\n                group: this.config.group,\n            };\n            // Send registration request to server\n            const response = await this.post('/api/srp/register', request);\n            return {\n                success: response.success,\n                userID: response.user_id,\n                error: response.error,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error',\n            };\n        }\n    }\n    /**\n     * Authenticate a user with SRP.\n     *\n     * This performs the SRP authentication protocol:\n     * 1. Request salt and server's public ephemeral value (B)\n     * 2. Compute client's public ephemeral value (A) and proof (M1)\n     * 3. Send A and M1 to server\n     * 4. Verify server's proof (M2)\n     * 5. Derive session key (K)\n     *\n     * @param userID - User identifier\n     * @param password - User's password\n     * @returns Authentication result with session key\n     *\n     * @mitigation Tampering: Protocol ensures both parties have the correct password.\n     * @mitigation Information Disclosure: Session key is derived, not transmitted.\n     */\n    async authenticate(userID, password) {\n        try {\n            // Step 1: Begin authentication - get salt and B from server\n            const beginRequest = {\n                user_id: userID,\n                group: this.config.group,\n            };\n            const beginResponse = await this.post('/api/srp/authenticate/begin', beginRequest);\n            const salt = this.base64ToBytes(beginResponse.salt);\n            const B = bytesToBigInt(this.base64ToBytes(beginResponse.b));\n            // Get group parameters\n            const group = getGroup(beginResponse.group);\n            // Compute x = H(salt | H(userID | \":\" | password))\n            const x = await this.computeX(userID, password, salt);\n            // Generate client's private ephemeral value a (256 bits)\n            // @mitigation Elevation of Privilege: Cryptographically random a prevents prediction\n            const aBytes = new Uint8Array(32);\n            crypto.getRandomValues(aBytes);\n            const a = bytesToBigInt(aBytes);\n            // Compute A = g^a mod N\n            const A = this.modPow(group.g, a, group.N);\n            // Compute u = H(A | B)\n            const u = await this.computeU(A, B, group);\n            // Compute k = H(N | g)\n            const k = await computeK(group);\n            // Compute S = (B - kg^x)^(a + ux) mod N\n            const gx = this.modPow(group.g, x, group.N);\n            const kgx = (k * gx) % group.N;\n            let diff = (B - kgx) % group.N;\n            if (diff < 0n) {\n                diff += group.N;\n            }\n            const ux = u * x;\n            const aux = a + ux;\n            const S = this.modPow(diff, aux, group.N);\n            // Compute session key K = H(S)\n            const K = await this.hashSHA256(bigIntToBytes(S));\n            // Compute M1 = H(A | B | K)\n            const M1 = await this.computeM1(A, B, K);\n            // Step 2: Send A and M1 to server\n            const finishRequest = {\n                user_id: userID,\n                a: this.bytesToBase64(bigIntToBytes(A)),\n                m1: this.bytesToBase64(M1),\n            };\n            const finishResponse = await this.post('/api/srp/authenticate/finish', finishRequest);\n            if (!finishResponse.success) {\n                return {\n                    success: false,\n                    error: finishResponse.error || 'Authentication failed',\n                };\n            }\n            // Step 3: Verify server's proof M2\n            if (finishResponse.m2) {\n                const expectedM2 = await this.computeM2(A, M1, K);\n                const serverM2 = this.base64ToBytes(finishResponse.m2);\n                // @mitigation Tampering: Verify server's proof to prevent man-in-the-middle\n                if (!this.constantTimeCompare(expectedM2, serverM2)) {\n                    return {\n                        success: false,\n                        error: 'Server proof verification failed',\n                    };\n                }\n            }\n            return {\n                success: true,\n                sessionKey: K,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error',\n            };\n        }\n    }\n    /**\n     * Compute x = H(salt | H(userID | \":\" | password))\n     *\n     * This is the private key derivation from the password.\n     */\n    async computeX(userID, password, salt) {\n        // Inner hash: H(userID | \":\" | password)\n        const innerText = userID + ':' + password;\n        const innerBytes = new TextEncoder().encode(innerText);\n        const innerHash = await this.hashSHA256(innerBytes);\n        // Outer hash: H(salt | innerHash)\n        const combined = new Uint8Array(salt.length + innerHash.length);\n        combined.set(salt, 0);\n        combined.set(innerHash, salt.length);\n        const xHash = await this.hashSHA256(combined);\n        return bytesToBigInt(xHash);\n    }\n    /**\n     * Compute u = H(A | B)\n     */\n    async computeU(A, B, group) {\n        const NBytes = bigIntToBytes(group.N);\n        const ABytes = padBytes(bigIntToBytes(A), NBytes.length);\n        const BBytes = padBytes(bigIntToBytes(B), NBytes.length);\n        const combined = new Uint8Array(ABytes.length + BBytes.length);\n        combined.set(ABytes, 0);\n        combined.set(BBytes, ABytes.length);\n        const hash = await this.hashSHA256(combined);\n        return bytesToBigInt(hash);\n    }\n    /**\n     * Compute M1 = H(A | B | K)\n     * Client's proof of session key possession.\n     */\n    async computeM1(A, B, K) {\n        const ABytes = bigIntToBytes(A);\n        const BBytes = bigIntToBytes(B);\n        const combined = new Uint8Array(ABytes.length + BBytes.length + K.length);\n        combined.set(ABytes, 0);\n        combined.set(BBytes, ABytes.length);\n        combined.set(K, ABytes.length + BBytes.length);\n        return this.hashSHA256(combined);\n    }\n    /**\n     * Compute M2 = H(A | M1 | K)\n     * Server's proof of session key possession.\n     */\n    async computeM2(A, M1, K) {\n        const ABytes = bigIntToBytes(A);\n        const combined = new Uint8Array(ABytes.length + M1.length + K.length);\n        combined.set(ABytes, 0);\n        combined.set(M1, ABytes.length);\n        combined.set(K, ABytes.length + M1.length);\n        return this.hashSHA256(combined);\n    }\n    /**\n     * SHA-256 hash function using WebCrypto.\n     */\n    async hashSHA256(data) {\n        // Yes, it accepts `new T(instance of T)` but doesn't accept `T`.\n        // Make it make sense, Typescript!\n        // TODO: Actually fix that abomination.\n        const hashBuffer = await crypto.subtle.digest('SHA-256', new Uint8Array(data));\n        return new Uint8Array(hashBuffer);\n    }\n    /**\n     * Modular exponentiation: base^exp mod modulus\n     *\n     * Uses JavaScript's native BigInt which handles large numbers efficiently.\n     */\n    modPow(base, exp, modulus) {\n        let result = 1n;\n        base = base % modulus;\n        while (exp > 0n) {\n            if (exp % 2n === 1n) {\n                result = (result * base) % modulus;\n            }\n            exp = exp / 2n;\n            base = (base * base) % modulus;\n        }\n        return result;\n    }\n    /**\n     * Constant-time comparison to prevent timing attacks.\n     *\n     * @mitigation Information Disclosure: Prevents timing attacks that could leak password info.\n     */\n    constantTimeCompare(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        let diff = 0;\n        for (let i = 0; i < a.length; i++) {\n            diff |= a[i] ^ b[i];\n        }\n        return diff === 0;\n    }\n    /**\n     * Convert bytes to Base64 (URL-safe).\n     */\n    bytesToBase64(bytes) {\n        const base64 = btoa(String.fromCharCode(...bytes));\n        return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n    }\n    /**\n     * Convert Base64 (URL-safe) to bytes.\n     */\n    base64ToBytes(base64) {\n        // Convert URL-safe Base64 to standard Base64\n        const standardBase64 = base64.replace(/-/g, '+').replace(/_/g, '/');\n        // Add padding if needed\n        const padded = standardBase64 + '===='.slice(0, (4 - (standardBase64.length % 4)) % 4);\n        const binary = atob(padded);\n        const bytes = new Uint8Array(binary.length);\n        for (let i = 0; i < binary.length; i++) {\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    }\n    /**\n     * HTTP POST helper.\n     */\n    async post(endpoint, body) {\n        const url = this.config.baseURL + endpoint;\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(body),\n        });\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n        return response.json();\n    }\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "SRPClient", "bigIntToBytes", "bytesToBigInt", "computeK", "getGroup", "padBytes", "getGroup", "groupID", "getGroup3", "getGroup4", "getGroup5", "N", "g", "computeK", "group", "NBytes", "bigIntToBytes", "gBytes", "paddedG", "combined", "hashBuffer", "hashBytes", "bytesToBigInt", "value", "hex", "paddedHex", "bytes", "i", "byte", "padBytes", "length", "padded", "SRPClient", "config", "userID", "password", "group", "getGroup", "salt", "x", "v", "request", "bigIntToBytes", "response", "error", "beginRequest", "beginResponse", "B", "bytesToBigInt", "aBytes", "a", "A", "u", "k", "computeK", "gx", "kgx", "diff", "ux", "aux", "K", "M1", "finishRequest", "finishResponse", "expectedM2", "serverM2", "innerText", "innerBytes", "innerHash", "combined", "xHash", "NBytes", "ABytes", "padBytes", "BBytes", "hash", "data", "hashBuffer", "base", "exp", "modulus", "result", "b", "i", "bytes", "base64", "standardBase64", "padded", "binary", "endpoint", "body", "url"]
}
